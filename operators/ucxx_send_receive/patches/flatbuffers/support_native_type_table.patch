diff --git a/src/idl_gen_cpp.cpp b/src/idl_gen_cpp.cpp
index 37fbccc5..892d4275 100644
--- a/src/idl_gen_cpp.cpp
+++ b/src/idl_gen_cpp.cpp
@@ -485,7 +485,12 @@ class CppGenerator : public BaseGenerator {
             }
           }
 
-          if (!struct_def->fixed) { code_ += "struct " + nativeName + ";"; }
+          // Don't declare a new object API struct type if the table is a
+          // native type.
+          const auto native_type = struct_def->attributes.Lookup("native_type");
+          if (!struct_def->fixed && !native_type) {
+            code_ += "struct " + nativeName + ";";
+          }
         }
         code_ += "";
       }
@@ -863,12 +868,22 @@ class CppGenerator : public BaseGenerator {
 
   static std::string NativeName(const std::string &name, const StructDef *sd,
                                 const IDLOptions &opts) {
+    // If the table is a native_type, return the native_type name.
+    if (auto native_type = sd->attributes.Lookup("native_type"); native_type) {
+      return native_type->constant;
+    }
+
     return sd && !sd->fixed ? opts.object_prefix + name + opts.object_suffix
                             : name;
   }
 
   std::string WrapNativeNameInNameSpace(const StructDef &struct_def,
                                         const IDLOptions &opts) {
+    // If the table is a native_type, return the native_type name.
+    if (auto native_type = struct_def.attributes.Lookup("native_type");
+        native_type) {
+      return native_type->constant;
+    }
     return WrapInNameSpace(struct_def.defined_namespace,
                            NativeName(Name(struct_def), &struct_def, opts));
   }
@@ -2793,7 +2808,11 @@ class CppGenerator : public BaseGenerator {
 
   // Generate an accessor struct, builder structs & function for a table.
   void GenTable(const StructDef &struct_def) {
-    if (opts_.generate_object_based_api) { GenNativeTable(struct_def); }
+    // Don't generate an object API struct for the table if it is a native type.
+    const auto native_type = struct_def.attributes.Lookup("native_type");
+    if (opts_.generate_object_based_api && !native_type) {
+      GenNativeTable(struct_def);
+    }
 
     // Generate an accessor struct, with methods of the form:
     // type name() const { return GetField<type>(offset, defaultval); }
@@ -3632,7 +3651,11 @@ class CppGenerator : public BaseGenerator {
 
   // Generate code for tables that needs to come after the regular definition.
   void GenTablePost(const StructDef &struct_def) {
-    if (opts_.generate_object_based_api) { GenNativeTablePost(struct_def); }
+    // Don't generate an object API struct for the table if it is a native type.
+    const auto native_type = struct_def.attributes.Lookup("native_type");
+    if (opts_.generate_object_based_api && !native_type) {
+      GenNativeTablePost(struct_def);
+    }
 
     code_.SetValue("STRUCT_NAME", Name(struct_def));
     code_.SetValue("NATIVE_NAME",
@@ -3663,31 +3686,36 @@ class CppGenerator : public BaseGenerator {
       code_ += "  return _o.release();";
       code_ += "}";
       code_ += "";
-      code_ +=
-          "inline " + TableUnPackToSignature(struct_def, false, opts_) + " {";
-      code_ += "  (void)_o;";
-      code_ += "  (void)_resolver;";
 
-      for (auto it = struct_def.fields.vec.begin();
-           it != struct_def.fields.vec.end(); ++it) {
-        const auto &field = **it;
-        if (field.deprecated) { continue; }
-
-        // Assign a value from |this| to |_o|.   Values from |this| are stored
-        // in a variable |_e| by calling this->field_type().  The value is then
-        // assigned to |_o| using the GenUnpackFieldStatement.
-        const bool is_union = field.value.type.base_type == BASE_TYPE_UTYPE;
-        const auto statement =
-            GenUnpackFieldStatement(field, is_union ? *(it + 1) : nullptr);
-
-        code_.SetValue("FIELD_NAME", Name(field));
-        auto prefix = "  { auto _e = {{FIELD_NAME}}(); ";
-        auto check = IsScalar(field.value.type.base_type) ? "" : "if (_e) ";
-        auto postfix = " }";
-        code_ += std::string(prefix) + check + statement + postfix;
+      if (!native_type) {
+        // Generate an Unpack method for the C++ object if that table does not
+        // have a native type.
+        code_ +=
+            "inline " + TableUnPackToSignature(struct_def, false, opts_) + " {";
+        code_ += "  (void)_o;";
+        code_ += "  (void)_resolver;";
+
+        for (auto it = struct_def.fields.vec.begin();
+             it != struct_def.fields.vec.end(); ++it) {
+          const auto &field = **it;
+          if (field.deprecated) { continue; }
+
+          // Assign a value from |this| to |_o|.   Values from |this| are stored
+          // in a variable |_e| by calling this->field_type().  The value is
+          // then assigned to |_o| using the GenUnpackFieldStatement.
+          const bool is_union = field.value.type.base_type == BASE_TYPE_UTYPE;
+          const auto statement =
+              GenUnpackFieldStatement(field, is_union ? *(it + 1) : nullptr);
+
+          code_.SetValue("FIELD_NAME", Name(field));
+          auto prefix = "  { auto _e = {{FIELD_NAME}}(); ";
+          auto check = IsScalar(field.value.type.base_type) ? "" : "if (_e) ";
+          auto postfix = " }";
+          code_ += std::string(prefix) + check + statement + postfix;
+        }
+        code_ += "}";
+        code_ += "";
       }
-      code_ += "}";
-      code_ += "";
 
       // Generate the X::Pack member function that simply calls the global
       // CreateX function.
@@ -3696,63 +3724,69 @@ class CppGenerator : public BaseGenerator {
       code_ += "}";
       code_ += "";
 
-      // Generate a CreateX method that works with an unpacked C++ object.
-      code_ +=
-          "inline " + TableCreateSignature(struct_def, false, opts_) + " {";
-      code_ += "  (void)_rehasher;";
-      code_ += "  (void)_o;";
-
-      code_ +=
-          "  struct _VectorArgs "
-          "{ " +
-          GetBuilder() +
-          " *__fbb; "
-          "const " +
-          NativeName(Name(struct_def), &struct_def, opts_) +
-          "* __o; "
-          "const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { "
-          "&_fbb, _o, _rehasher}; (void)_va;";
-
-      for (auto it = struct_def.fields.vec.begin();
-           it != struct_def.fields.vec.end(); ++it) {
-        auto &field = **it;
-        if (field.deprecated) { continue; }
-        if (IsVector(field.value.type)) {
-          const std::string force_align_code =
-              GenVectorForceAlign(field, "_o->" + Name(field) + ".size()");
-          if (!force_align_code.empty()) { code_ += "  " + force_align_code; }
-        }
-        code_ += "  auto _" + Name(field) + " = " + GenCreateParam(field) + ";";
-      }
-      // Need to call "Create" with the struct namespace.
-      const auto qualified_create_name =
-          struct_def.defined_namespace->GetFullyQualifiedName("Create");
-      code_.SetValue("CREATE_NAME", TranslateNameSpace(qualified_create_name));
-
-      code_ += "  return {{CREATE_NAME}}{{STRUCT_NAME}}(";
-      code_ += "      _fbb\\";
-      for (const auto &field : struct_def.fields.vec) {
-        if (field->deprecated) { continue; }
+      if (!native_type) {
+        // Generate a CreateX method that works with an unpacked C++ object if
+        // it does not have a native type.
+        code_ +=
+            "inline " + TableCreateSignature(struct_def, false, opts_) + " {";
+        code_ += "  (void)_rehasher;";
+        code_ += "  (void)_o;";
 
-        bool pass_by_address = false;
-        if (field->value.type.base_type == BASE_TYPE_STRUCT) {
-          if (IsStruct(field->value.type)) {
-            auto native_type =
-                field->value.type.struct_def->attributes.Lookup("native_type");
-            if (native_type) { pass_by_address = true; }
+        code_ +=
+            "  struct _VectorArgs "
+            "{ " +
+            GetBuilder() +
+            " *__fbb; "
+            "const " +
+            NativeName(Name(struct_def), &struct_def, opts_) +
+            "* __o; "
+            "const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { "
+            "&_fbb, _o, _rehasher}; (void)_va;";
+
+        for (auto it = struct_def.fields.vec.begin();
+             it != struct_def.fields.vec.end(); ++it) {
+          auto &field = **it;
+          if (field.deprecated) { continue; }
+          if (IsVector(field.value.type)) {
+            const std::string force_align_code =
+                GenVectorForceAlign(field, "_o->" + Name(field) + ".size()");
+            if (!force_align_code.empty()) { code_ += "  " + force_align_code; }
           }
+          code_ +=
+              "  auto _" + Name(field) + " = " + GenCreateParam(field) + ";";
         }
+        // Need to call "Create" with the struct namespace.
+        const auto qualified_create_name =
+            struct_def.defined_namespace->GetFullyQualifiedName("Create");
+        code_.SetValue("CREATE_NAME",
+                       TranslateNameSpace(qualified_create_name));
+
+        code_ += "  return {{CREATE_NAME}}{{STRUCT_NAME}}(";
+        code_ += "      _fbb\\";
+        for (const auto &field : struct_def.fields.vec) {
+          if (field->deprecated) { continue; }
+
+          bool pass_by_address = false;
+          if (field->value.type.base_type == BASE_TYPE_STRUCT) {
+            if (IsStruct(field->value.type)) {
+              auto native_type =
+                  field->value.type.struct_def->attributes.Lookup(
+                      "native_type");
+              if (native_type) { pass_by_address = true; }
+            }
+          }
 
-        // Call the CreateX function using values from |_o|.
-        if (pass_by_address) {
-          code_ += ",\n      &_" + Name(*field) + "\\";
-        } else {
-          code_ += ",\n      _" + Name(*field) + "\\";
+          // Call the CreateX function using values from |_o|.
+          if (pass_by_address) {
+            code_ += ",\n      &_" + Name(*field) + "\\";
+          } else {
+            code_ += ",\n      _" + Name(*field) + "\\";
+          }
         }
+        code_ += ");";
+        code_ += "}";
+        code_ += "";
       }
-      code_ += ");";
-      code_ += "}";
-      code_ += "";
     }
   }
 
